-- Fix Critical Email Exposure Issue
-- Remove the overly permissive QTRA arborist profile policy
DROP POLICY IF EXISTS "QTRA arborists can view basic profile info of tree creators" ON public.profiles;

-- Create a security definer function to check if QTRA arborist has legitimate access
CREATE OR REPLACE FUNCTION public.qtra_arborist_has_assessment_access(profile_user_id uuid)
RETURNS boolean
LANGUAGE sql
STABLE SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 
    FROM assessments a
    JOIN trees t ON t.id = a.tree_id
    WHERE t.created_by = profile_user_id
    AND a.assessor_id = auth.uid()
    AND (a.status IN ('draft', 'completed') OR a.assessment_date >= CURRENT_DATE - INTERVAL '30 days')
  );
$$;

-- Create a new, more restrictive policy for QTRA arborists
-- Only allows viewing display_name (not email) and only for trees they're actively assessing
CREATE POLICY "QTRA arborists can view limited profile info for active assessments"
ON public.profiles
FOR SELECT
USING (
  has_role(auth.uid(), 'qtra_arborist'::app_role) 
  AND public.qtra_arborist_has_assessment_access(profiles.id)
);

-- Create audit logs table for security monitoring
CREATE TABLE IF NOT EXISTS public.audit_logs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  action text NOT NULL,
  table_name text NOT NULL,
  record_id uuid,
  timestamp timestamp with time zone NOT NULL DEFAULT now(),
  details jsonb DEFAULT '{}'::jsonb
);

-- Enable RLS on audit logs
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Only admins can view audit logs
CREATE POLICY "Only admins can view audit logs"
ON public.audit_logs
FOR SELECT
USING (has_role(auth.uid(), 'admin'::app_role));

-- Strengthen user role management - only admins can modify user roles
CREATE POLICY "Only admins can manage user roles"
ON public.user_roles
FOR ALL
USING (has_role(auth.uid(), 'admin'::app_role))
WITH CHECK (has_role(auth.uid(), 'admin'::app_role));

-- Add policy to prevent role escalation
CREATE OR REPLACE FUNCTION public.prevent_role_escalation()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Prevent users from giving themselves admin roles
  IF NEW.user_id = auth.uid() AND NEW.role = 'admin' THEN
    RAISE EXCEPTION 'Users cannot assign admin role to themselves';
  END IF;
  
  -- Log role changes
  INSERT INTO public.audit_logs (
    user_id,
    action,
    table_name,
    record_id,
    details
  ) VALUES (
    auth.uid(),
    'role_change',
    'user_roles',
    NEW.user_id,
    jsonb_build_object(
      'old_role', COALESCE(OLD.role::text, 'none'),
      'new_role', NEW.role::text
    )
  );
  
  RETURN NEW;
END;
$$;

-- Create trigger for role change prevention and logging
DROP TRIGGER IF EXISTS prevent_role_escalation_trigger ON public.user_roles;
CREATE TRIGGER prevent_role_escalation_trigger
  BEFORE INSERT OR UPDATE ON public.user_roles
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_role_escalation();

-- Add rate limiting table for authentication attempts
CREATE TABLE IF NOT EXISTS public.auth_attempts (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email text NOT NULL,
  ip_address inet,
  attempt_time timestamp with time zone NOT NULL DEFAULT now(),
  success boolean DEFAULT false
);

-- Enable RLS on auth attempts
ALTER TABLE public.auth_attempts ENABLE ROW LEVEL SECURITY;

-- Only admins can view auth attempts
CREATE POLICY "Only admins can view auth attempts"
ON public.auth_attempts
FOR SELECT
USING (has_role(auth.uid(), 'admin'::app_role));

-- Function to clean up old auth attempts
CREATE OR REPLACE FUNCTION public.cleanup_old_auth_attempts()
RETURNS void
LANGUAGE sql
SECURITY DEFINER
AS $$
  DELETE FROM public.auth_attempts 
  WHERE attempt_time < now() - INTERVAL '24 hours';
$$;

-- Add function to log sensitive operations
CREATE OR REPLACE FUNCTION public.log_sensitive_operation(
  operation_type text,
  target_table text,
  target_id uuid DEFAULT NULL,
  additional_details jsonb DEFAULT '{}'::jsonb
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.audit_logs (
    user_id,
    action,
    table_name,
    record_id,
    details
  ) VALUES (
    auth.uid(),
    operation_type,
    target_table,
    target_id,
    additional_details
  );
END;
$$;