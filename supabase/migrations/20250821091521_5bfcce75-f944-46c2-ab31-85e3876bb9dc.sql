-- Fix Critical Email Exposure Issue
-- Remove the overly permissive QTRA arborist profile policy
DROP POLICY IF EXISTS "QTRA arborists can view basic profile info of tree creators" ON public.profiles;

-- Create a security definer function to check if QTRA arborist has legitimate access
CREATE OR REPLACE FUNCTION public.qtra_arborist_has_assessment_access(profile_user_id uuid)
RETURNS boolean
LANGUAGE sql
STABLE SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 
    FROM assessments a
    JOIN trees t ON t.id = a.tree_id
    WHERE t.created_by = profile_user_id
    AND a.assessor_id = auth.uid()
    AND (a.status = 'in_progress' OR a.assessment_date >= CURRENT_DATE - INTERVAL '30 days')
  );
$$;

-- Create a new, more restrictive policy for QTRA arborists
-- Only allows viewing display_name (not email) and only for trees they're actively assessing
CREATE POLICY "QTRA arborists can view limited profile info for active assessments"
ON public.profiles
FOR SELECT
USING (
  has_role(auth.uid(), 'qtra_arborist'::app_role) 
  AND public.qtra_arborist_has_assessment_access(profiles.id)
);

-- Ensure the profiles table has proper column-level security
-- Create a view that restricts what QTRA arborists can see
CREATE OR REPLACE VIEW public.limited_profiles AS
SELECT 
  id,
  display_name,
  avatar_url,
  -- Explicitly exclude email and other sensitive fields
  created_at
FROM public.profiles;

-- Grant access to the limited view for QTRA arborists
GRANT SELECT ON public.limited_profiles TO authenticated;

-- Create RLS policy for the limited view
ALTER VIEW public.limited_profiles SET (security_invoker = true);

-- Add audit logging function for profile access
CREATE OR REPLACE FUNCTION public.log_profile_access()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Log when QTRA arborists access profiles
  IF has_role(auth.uid(), 'qtra_arborist'::app_role) THEN
    INSERT INTO public.audit_logs (
      user_id,
      action,
      table_name,
      record_id,
      timestamp
    ) VALUES (
      auth.uid(),
      'profile_access',
      'profiles',
      NEW.id,
      now()
    );
  END IF;
  RETURN NEW;
END;
$$;

-- Create audit logs table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.audit_logs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  action text NOT NULL,
  table_name text NOT NULL,
  record_id uuid,
  timestamp timestamp with time zone NOT NULL DEFAULT now(),
  details jsonb DEFAULT '{}'::jsonb
);

-- Enable RLS on audit logs
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Only admins can view audit logs
CREATE POLICY "Only admins can view audit logs"
ON public.audit_logs
FOR SELECT
USING (has_role(auth.uid(), 'admin'::app_role));

-- Create trigger for profile access logging
DROP TRIGGER IF EXISTS profile_access_audit ON public.profiles;
CREATE TRIGGER profile_access_audit
  AFTER SELECT ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.log_profile_access();

-- Strengthen user role management
-- Ensure only admins can modify user roles
DROP POLICY IF EXISTS "Only admins can manage user roles" ON public.user_roles;
CREATE POLICY "Only admins can manage user roles"
ON public.user_roles
FOR ALL
USING (has_role(auth.uid(), 'admin'::app_role))
WITH CHECK (has_role(auth.uid(), 'admin'::app_role));

-- Add policy to prevent role escalation
CREATE OR REPLACE FUNCTION public.prevent_role_escalation()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Prevent users from giving themselves admin roles
  IF NEW.user_id = auth.uid() AND NEW.role = 'admin' THEN
    RAISE EXCEPTION 'Users cannot assign admin role to themselves';
  END IF;
  
  -- Log role changes
  INSERT INTO public.audit_logs (
    user_id,
    action,
    table_name,
    record_id,
    details
  ) VALUES (
    auth.uid(),
    'role_change',
    'user_roles',
    NEW.user_id,
    jsonb_build_object(
      'old_role', COALESCE(OLD.role::text, 'none'),
      'new_role', NEW.role::text
    )
  );
  
  RETURN NEW;
END;
$$;

-- Create trigger for role change prevention and logging
DROP TRIGGER IF EXISTS prevent_role_escalation_trigger ON public.user_roles;
CREATE TRIGGER prevent_role_escalation_trigger
  BEFORE INSERT OR UPDATE ON public.user_roles
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_role_escalation();

-- Add rate limiting for authentication attempts (using a simple table-based approach)
CREATE TABLE IF NOT EXISTS public.auth_attempts (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email text NOT NULL,
  ip_address inet,
  attempt_time timestamp with time zone NOT NULL DEFAULT now(),
  success boolean DEFAULT false
);

-- Enable RLS on auth attempts
ALTER TABLE public.auth_attempts ENABLE ROW LEVEL SECURITY;

-- Only admins can view auth attempts
CREATE POLICY "Only admins can view auth attempts"
ON public.auth_attempts
FOR SELECT
USING (has_role(auth.uid(), 'admin'::app_role));

-- Clean up old auth attempts (older than 24 hours)
CREATE OR REPLACE FUNCTION public.cleanup_old_auth_attempts()
RETURNS void
LANGUAGE sql
SECURITY DEFINER
AS $$
  DELETE FROM public.auth_attempts 
  WHERE attempt_time < now() - INTERVAL '24 hours';
$$;